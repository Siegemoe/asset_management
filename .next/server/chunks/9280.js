exports.id=9280,exports.ids=[9280],exports.modules={31001:(a,b,c)=>{"use strict";c.d(b,{U:()=>e});let d=[];class e{static generateId(){return`audit_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}static async logLoginAttempt(a,b,c,e,f,g){try{let b={id:this.generateId(),eventType:c?"LOGIN_SUCCESS":"LOGIN_FAILURE",action:"login",description:c?"Successful login":"Failed login attempt",userId:a,severity:c?"LOW":"MEDIUM",ipAddress:e,userAgent:f,createdAt:new Date};d.unshift(b),d.length>1e3&&d.splice(1e3),console.log("AUDIT:",b)}catch(a){console.error("Failed to log login attempt:",a)}}static async logLogout(a,b,c){let e={id:this.generateId(),eventType:"LOGOUT",action:"logout",description:"User logout",userId:a,severity:"LOW",ipAddress:b,userAgent:c,createdAt:new Date};d.unshift(e),d.length>1e3&&d.splice(1e3),console.log("AUDIT:",e)}static async logDataAccess(a,b,c,e,f,g){let h={id:this.generateId(),eventType:"DATA_ACCESS",action:`${c}_${b}`,description:`User accessed ${b} data`,userId:a,severity:"LOW",ipAddress:f,userAgent:g,createdAt:new Date};d.unshift(h),d.length>1e3&&d.splice(1e3),console.log("AUDIT:",h)}static async logDataModification(a,b,c,e,f,g,h){let i={id:this.generateId(),eventType:"DATA_MODIFICATION",action:`${c}_${b}`,description:`User ${c}ed ${b}`,userId:a,severity:"delete"===c?"MEDIUM":"LOW",ipAddress:g,userAgent:h,createdAt:new Date};d.unshift(i),d.length>1e3&&d.splice(1e3),console.log("AUDIT:",i)}static async logSecurityEvent(a,b,c={},e,f){let g={id:this.generateId(),eventType:a,action:"security_event",description:`${a} event occurred`,userId:b,severity:"UNAUTHORIZED_ACCESS"===a?"HIGH":"MEDIUM",details:c,ipAddress:e,userAgent:f,createdAt:new Date};d.unshift(g),d.length>1e3&&d.splice(1e3),console.log("SECURITY:",g)}static async getRecentEvents(a=100){return d.slice(0,a)}static async getSecurityEvents(a=50){return d.filter(a=>"HIGH"===a.severity||"CRITICAL"===a.severity||a.eventType?.includes("SECURITY")||"UNAUTHORIZED_ACCESS"===a.eventType||"ACCOUNT_LOCKED"===a.eventType).slice(0,a)}}},35324:(a,b,c)=>{"use strict";c.d(b,{C:()=>g});var d=c(31001),e=c(93061);class f{static async createSession(a,b,c,d,f,g){let h=new Date(Date.now()+18e5),i={id:`session_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,userId:a,sessionToken:b,refreshToken:c||void 0,deviceInfo:d||void 0,ipAddress:f||void 0,userAgent:g||void 0,createdAt:new Date,lastActivity:new Date,expiresAt:h,status:"active"};return await e.z.userSession.create({data:{id:i.id,userId:i.userId,sessionToken:i.sessionToken,refreshToken:i.refreshToken||null,deviceInfo:i.deviceInfo||null,ipAddress:i.ipAddress||null,userAgent:i.userAgent||null,createdAt:i.createdAt,lastActivity:i.lastActivity,expiresAt:i.expiresAt,status:i.status.toUpperCase()}}),i}static async getSession(a){try{let b=await e.z.userSession.findUnique({where:{sessionToken:a}});if(!b)return null;if(b.expiresAt<new Date)return await e.z.userSession.update({where:{id:b.id},data:{status:"EXPIRED"}}),null;if("REVOKED"===b.status||"EXPIRED"===b.status)return null;return{id:b.id,userId:b.userId,sessionToken:b.sessionToken,refreshToken:b.refreshToken||void 0,deviceInfo:b.deviceInfo||void 0,ipAddress:b.ipAddress||void 0,userAgent:b.userAgent||void 0,createdAt:b.createdAt,lastActivity:b.lastActivity,expiresAt:b.expiresAt,status:b.status.toLowerCase()}}catch(a){return console.error("Error getting session:",a),null}}static async validateSession(a,b,c){try{let b=await this.getSession(a);if(!b)return{valid:!1,reason:"Session not found or expired"};return await this.updateActivity(a),{valid:!0,session:b}}catch(a){return console.error("Error validating session:",a),{valid:!1,reason:"Session validation failed"}}}static async updateActivity(a){try{await e.z.userSession.update({where:{sessionToken:a},data:{lastActivity:new Date}})}catch(a){console.error("Error updating session activity:",a)}}static async invalidateSession(a){try{return(await e.z.userSession.updateMany({where:{sessionToken:a},data:{status:"REVOKED"}})).count>0}catch(a){return console.error("Error invalidating session:",a),!1}}static async invalidateAllUserSessions(a){try{return(await e.z.userSession.updateMany({where:{userId:a,status:"ACTIVE"},data:{status:"REVOKED"}})).count}catch(a){return console.error("Error invalidating all user sessions:",a),0}}static async getUserSessions(a){try{return(await e.z.userSession.findMany({where:{userId:a,status:"ACTIVE"},orderBy:{lastActivity:"desc"}})).map(a=>({id:a.id,userId:a.userId,sessionToken:a.sessionToken,refreshToken:a.refreshToken||void 0,deviceInfo:a.deviceInfo||void 0,ipAddress:a.ipAddress||void 0,userAgent:a.userAgent||void 0,createdAt:a.createdAt,lastActivity:a.lastActivity,expiresAt:a.expiresAt,status:a.status.toLowerCase()}))}catch(a){return console.error("Error getting user sessions:",a),[]}}static async cleanupExpiredSessions(){try{return(await e.z.userSession.deleteMany({where:{OR:[{expiresAt:{lt:new Date}},{status:"EXPIRED"}]}})).count}catch(a){return console.error("Error cleaning up expired sessions:",a),0}}static async getSessionStats(){try{let a=new Date,[b,c,d]=await Promise.all([e.z.userSession.count(),e.z.userSession.count({where:{status:"ACTIVE",expiresAt:{gt:a}}}),e.z.userSession.count({where:{OR:[{expiresAt:{lt:a}},{status:"EXPIRED"}]}})]),f=await e.z.userSession.findMany({where:{status:"ACTIVE"},select:{createdAt:!0}}),g=f.length>0?f.reduce((b,c)=>b+(a.getTime()-c.createdAt.getTime()),0)/f.length:0;return{totalSessions:b,activeSessions:c,expiredSessions:d,averageSessionDuration:Math.round(g/1e3/60)}}catch(a){return console.error("Error getting session stats:",a),{totalSessions:0,activeSessions:0,expiredSessions:0,averageSessionDuration:0}}}}class g{static{this.config={sessionTimeout:30,maxConcurrentSessions:3,refreshTokenRotation:!0,requireHTTPS:!0,sessionFingerprinting:!0}}static async createSession(a,b,c,e,g,h){let i=await f.createSession(a,b,c,e,g,h);return await d.U.logSecurityEvent("PASSWORD_CHANGE",a,{action:"session_created",sessionId:i.id,deviceInfo:e,timestamp:new Date().toISOString()},g,h),i}static async validateSession(a,b,c){return await f.validateSession(a,b,c)}static async refreshSession(a,b,c){try{if(this.config.refreshTokenRotation){let e=this.generateSecureToken(32),f=this.generateSecureToken(32);return await d.U.logSecurityEvent("PASSWORD_CHANGE","system",{action:"session_refreshed",oldRefreshToken:a.substring(0,8)+"...",newRefreshToken:f.substring(0,8)+"...",timestamp:new Date().toISOString()},b,c),{success:!0,newSessionToken:e,newRefreshToken:f}}return{success:!1,reason:"Token rotation disabled"}}catch(a){return console.error("Error refreshing session:",a),{success:!1,reason:"Session refresh failed"}}}static async invalidateSession(a,b,c="manual_invalidation",e,g){let h=await f.invalidateSession(a);return h&&await d.U.logSecurityEvent("PASSWORD_CHANGE",b||"system",{action:"session_invalidated",reason:c,sessionToken:a.substring(0,8)+"...",timestamp:new Date().toISOString()},e,g),{success:h}}static async invalidateAllUserSessions(a,b="security_reason",c,e){let g=await f.invalidateAllUserSessions(a);return await d.U.logSecurityEvent("PASSWORD_CHANGE",a,{action:"all_sessions_invalidated",reason:b,invalidatedCount:g,timestamp:new Date().toISOString()},c,e),{success:!0,invalidatedCount:g}}static async getUserSessions(a){return await f.getUserSessions(a)}static async cleanupExpiredSessions(){return await f.cleanupExpiredSessions()}static async checkSuspiciousActivity(a,b,c){let e=[],g=!1;try{let h=await f.getUserSessions(a),i=[...new Set(h.map(a=>a.ipAddress).filter(Boolean))];i.length>1&&!i.includes(b)&&(e.push("Multiple IP addresses detected"),g=!0);let j=[...new Set(h.map(a=>a.userAgent).filter(Boolean))];return j.length>1&&!j.includes(c)&&(e.push("Multiple devices detected"),g=!0),h.filter(a=>Date.now()-a.createdAt.getTime()<3e5).length>this.config.maxConcurrentSessions&&(e.push("Rapid session creation detected"),g=!0),g&&await d.U.logSecurityEvent("UNAUTHORIZED_ACCESS",a,{action:"suspicious_activity",reasons:e,currentIpAddress:b,currentUserAgent:c},b,c),{suspicious:g,reasons:e}}catch(a){return console.error("Error checking suspicious activity:",a),{suspicious:!1,reasons:[]}}}static generateSecureToken(a){let b="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",c="";for(let d=0;d<a;d++)c+=b.charAt(Math.floor(Math.random()*b.length));return c}static async getSessionStats(){return await f.getSessionStats()}static updateConfig(a){this.config={...this.config,...a}}static getConfig(){return{...this.config}}}},78335:()=>{},93061:(a,b,c)=>{"use strict";c.d(b,{z:()=>h});var d=c(60030),e=c(1885),f=c(93699);let g=globalThis,h=g.prisma??new d.PrismaClient({datasources:{db:{url:f.nH.url}}}).$extends((0,e.WU)());f.yz&&(g.prisma=h)},93699:(a,b,c)=>{"use strict";c.d(b,{fl:()=>g,nH:()=>f,yz:()=>h});var d=c(22772);let e=d.Ikc({DATABASE_URL:d.YjP().min(1,"Database URL is required"),DIRECT_URL:d.YjP().optional(),GOOGLE_CLIENT_ID:d.YjP().min(1,"Google Client ID is required"),GOOGLE_CLIENT_SECRET:d.YjP().min(1,"Google Client Secret is required"),NEXTAUTH_URL:d.YjP().url().optional().default("http://localhost:3000"),NEXTAUTH_SECRET:d.YjP().min(32,"NextAuth secret must be at least 32 characters"),NODE_ENV:d.k5n(["development","production","test"]).default("development")}).parse(process.env),f={url:e.DATABASE_URL,directUrl:e.DIRECT_URL},g={googleClientId:e.GOOGLE_CLIENT_ID,googleClientSecret:e.GOOGLE_CLIENT_SECRET,url:e.NEXTAUTH_URL,secret:e.NEXTAUTH_SECRET},h="development"===e.NODE_ENV;e.NODE_ENV},96487:()=>{}};