{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/lib/security/simpleAuditLogger.ts"],"sourcesContent":["// Simple Audit Logger - works with existing schema\r\nimport { prisma } from \"@/lib/prisma\"\r\n\r\nexport interface AuditEvent {\r\n  id: string\r\n  userId?: string | undefined\r\n  action: string\r\n  resource?: string\r\n  details?: Record<string, any>\r\n  ipAddress?: string | undefined\r\n  userAgent?: string | undefined\r\n  severity?: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'\r\n  eventType?: string\r\n  description?: string\r\n  createdAt: Date\r\n}\r\n\r\n// In-memory store for audit events (in production, this would be a database)\r\n// Start with empty store - no placeholder data\r\nconst auditEventsStore: AuditEvent[] = []\r\n\r\nexport class SimpleAuditLogger {\r\n  private static generateId(): string {\r\n    return `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\r\n  }\r\n\r\n  /**\r\n   * Log a login attempt (both success and failure)\r\n   */\r\n  static async logLoginAttempt(\r\n    userId: string | undefined,\r\n    email: string,\r\n    success: boolean,\r\n    ipAddress?: string,\r\n    userAgent?: string,\r\n    reason?: string\r\n  ) {\r\n    try {\r\n      const event: AuditEvent = {\r\n        id: this.generateId(),\r\n        eventType: success ? 'LOGIN_SUCCESS' : 'LOGIN_FAILURE',\r\n        action: 'login',\r\n        description: success ? 'Successful login' : 'Failed login attempt',\r\n        userId,\r\n        severity: success ? 'LOW' : 'MEDIUM',\r\n        ipAddress,\r\n        userAgent,\r\n        createdAt: new Date()\r\n      }\r\n\r\n      auditEventsStore.unshift(event)\r\n      // Keep only the last 1000 events\r\n      if (auditEventsStore.length > 1000) {\r\n        auditEventsStore.splice(1000)\r\n      }\r\n\r\n      console.log('AUDIT:', event)\r\n    } catch (error) {\r\n      console.error('Failed to log login attempt:', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log logout\r\n   */\r\n  static async logLogout(\r\n    userId: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    const event: AuditEvent = {\r\n      id: this.generateId(),\r\n      eventType: 'LOGOUT',\r\n      action: 'logout',\r\n      description: 'User logout',\r\n      userId,\r\n      severity: 'LOW',\r\n      ipAddress,\r\n      userAgent,\r\n      createdAt: new Date()\r\n    }\r\n\r\n    auditEventsStore.unshift(event)\r\n    if (auditEventsStore.length > 1000) {\r\n      auditEventsStore.splice(1000)\r\n    }\r\n\r\n    console.log('AUDIT:', event)\r\n  }\r\n\r\n  /**\r\n   * Log data access\r\n   */\r\n  static async logDataAccess(\r\n    userId: string,\r\n    resource: string,\r\n    action: 'read' | 'list' | 'search',\r\n    resourceId?: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    const event: AuditEvent = {\r\n      id: this.generateId(),\r\n      eventType: 'DATA_ACCESS',\r\n      action: `${action}_${resource}`,\r\n      description: `User accessed ${resource} data`,\r\n      userId,\r\n      severity: 'LOW',\r\n      ipAddress,\r\n      userAgent,\r\n      createdAt: new Date()\r\n    }\r\n\r\n    auditEventsStore.unshift(event)\r\n    if (auditEventsStore.length > 1000) {\r\n      auditEventsStore.splice(1000)\r\n    }\r\n\r\n    console.log('AUDIT:', event)\r\n  }\r\n\r\n  /**\r\n   * Log data modification\r\n   */\r\n  static async logDataModification(\r\n    userId: string,\r\n    resource: string,\r\n    action: 'create' | 'update' | 'delete',\r\n    resourceId?: string,\r\n    changes?: Record<string, any>,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    const event: AuditEvent = {\r\n      id: this.generateId(),\r\n      eventType: 'DATA_MODIFICATION',\r\n      action: `${action}_${resource}`,\r\n      description: `User ${action}ed ${resource}`,\r\n      userId,\r\n      severity: action === 'delete' ? 'MEDIUM' : 'LOW',\r\n      ipAddress,\r\n      userAgent,\r\n      createdAt: new Date()\r\n    }\r\n\r\n    auditEventsStore.unshift(event)\r\n    if (auditEventsStore.length > 1000) {\r\n      auditEventsStore.splice(1000)\r\n    }\r\n\r\n    console.log('AUDIT:', event)\r\n  }\r\n\r\n  /**\r\n   * Log security events\r\n   */\r\n  static async logSecurityEvent(\r\n    event: 'ACCOUNT_LOCKED' | 'PASSWORD_CHANGE' | 'UNAUTHORIZED_ACCESS',\r\n    userId: string,\r\n    details: Record<string, any> = {},\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    const auditEvent: AuditEvent = {\r\n      id: this.generateId(),\r\n      eventType: event,\r\n      action: 'security_event',\r\n      description: `${event} event occurred`,\r\n      userId,\r\n      severity: event === 'UNAUTHORIZED_ACCESS' ? 'HIGH' : 'MEDIUM',\r\n      details,\r\n      ipAddress,\r\n      userAgent,\r\n      createdAt: new Date()\r\n    }\r\n\r\n    auditEventsStore.unshift(auditEvent)\r\n    if (auditEventsStore.length > 1000) {\r\n      auditEventsStore.splice(1000)\r\n    }\r\n\r\n    console.log('SECURITY:', auditEvent)\r\n  }\r\n\r\n  /**\r\n   * Get recent events\r\n   */\r\n  static async getRecentEvents(limit: number = 100): Promise<AuditEvent[]> {\r\n    return auditEventsStore.slice(0, limit)\r\n  }\r\n\r\n  /**\r\n   * Get security events (high severity)\r\n   */\r\n  static async getSecurityEvents(limit: number = 50): Promise<AuditEvent[]> {\r\n    return auditEventsStore\r\n      .filter(event =>\r\n        event.severity === 'HIGH' ||\r\n        event.severity === 'CRITICAL' ||\r\n        event.eventType?.includes('SECURITY') ||\r\n        event.eventType === 'UNAUTHORIZED_ACCESS' ||\r\n        event.eventType === 'ACCOUNT_LOCKED'\r\n      )\r\n      .slice(0, limit)\r\n  }\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 179, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/lib/security/sessionManager.ts"],"sourcesContent":["// Enhanced Session Management Service\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { SimpleAuditLogger } from \"./simpleAuditLogger\"\r\n\r\nexport interface SessionConfig {\r\n  sessionTimeout: number // in minutes\r\n  maxConcurrentSessions: number\r\n  refreshTokenRotation: boolean\r\n  requireHTTPS: boolean\r\n  sessionFingerprinting: boolean\r\n}\r\n\r\nexport interface SessionInfo {\r\n  id: string\r\n  userId: string\r\n  sessionToken: string\r\n  refreshToken: string | undefined\r\n  deviceInfo: string | undefined\r\n  ipAddress: string | undefined\r\n  userAgent: string | undefined\r\n  createdAt: Date\r\n  lastActivity: Date\r\n  expiresAt: Date\r\n  status: 'active' | 'expired' | 'revoked'\r\n}\r\n\r\nexport class SessionManager {\r\n  private static config: SessionConfig = {\r\n    sessionTimeout: 30, // 30 minutes\r\n    maxConcurrentSessions: 3,\r\n    refreshTokenRotation: true,\r\n    requireHTTPS: true,\r\n    sessionFingerprinting: true,\r\n  }\r\n\r\n  // In-memory session storage (in production, this would be a database)\r\n  private static sessions: Map<string, SessionInfo> = new Map()\r\n\r\n  /**\r\n   * Create a new session\r\n   */\r\n  static async createSession(\r\n    userId: string,\r\n    sessionToken: string,\r\n    refreshToken?: string,\r\n    deviceInfo?: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ): Promise<SessionInfo> {\r\n    // Check concurrent session limit\r\n    await this.enforceSessionLimit(userId)\r\n\r\n    const expiresAt = new Date(Date.now() + this.config.sessionTimeout * 60 * 1000)\r\n\r\n    const now = new Date()\r\n    const sessionInfo: SessionInfo = {\r\n      id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n      userId,\r\n      sessionToken,\r\n      refreshToken: refreshToken || undefined,\r\n      deviceInfo: deviceInfo || undefined,\r\n      ipAddress: ipAddress || undefined,\r\n      userAgent: userAgent || undefined,\r\n      createdAt: now,\r\n      lastActivity: now,\r\n      expiresAt,\r\n      status: 'active'\r\n    }\r\n\r\n    // Store session in memory\r\n    this.sessions.set(sessionToken, sessionInfo)\r\n\r\n    // Log session creation\r\n    await SimpleAuditLogger.logSecurityEvent('PASSWORD_CHANGE', userId, {\r\n      action: 'session_created',\r\n      sessionId: sessionInfo.id,\r\n      deviceInfo,\r\n      timestamp: new Date().toISOString()\r\n    }, ipAddress, userAgent)\r\n\r\n    // In a real implementation, you would store this in the database\r\n    console.log('SESSION_CREATED:', sessionInfo)\r\n\r\n    return sessionInfo\r\n  }\r\n\r\n  /**\r\n   * Validate and refresh session\r\n   */\r\n  static async validateSession(sessionToken: string, ipAddress?: string, userAgent?: string): Promise<{\r\n    valid: boolean\r\n    session?: SessionInfo\r\n    reason?: string\r\n  }> {\r\n    try {\r\n      const session = this.sessions.get(sessionToken)\r\n      \r\n      if (!session) {\r\n        return { valid: false, reason: 'Session not found' }\r\n      }\r\n\r\n      if (session.expiresAt < new Date()) {\r\n        session.status = 'expired'\r\n        this.sessions.set(sessionToken, session)\r\n        return { valid: false, reason: 'Session expired' }\r\n      }\r\n\r\n      if (session.status !== 'active') {\r\n        return { valid: false, reason: `Session ${session.status}` }\r\n      }\r\n\r\n      // Update last activity\r\n      session.lastActivity = new Date()\r\n      this.sessions.set(sessionToken, session)\r\n\r\n      return { valid: true, session }\r\n    } catch (error) {\r\n      console.error('Error validating session:', error)\r\n      return { valid: false, reason: 'Session validation failed' }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Refresh session token\r\n   */\r\n  static async refreshSession(\r\n    refreshToken: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ): Promise<{\r\n    success: boolean\r\n    newSessionToken?: string\r\n    newRefreshToken?: string\r\n    reason?: string\r\n  }> {\r\n    try {\r\n      if (this.config.refreshTokenRotation) {\r\n        // Generate new tokens\r\n        const newSessionToken = this.generateSecureToken(32)\r\n        const newRefreshToken = this.generateSecureToken(32)\r\n\r\n        await SimpleAuditLogger.logSecurityEvent('PASSWORD_CHANGE', 'system', {\r\n          action: 'session_refreshed',\r\n          oldRefreshToken: refreshToken.substring(0, 8) + '...',\r\n          newRefreshToken: newRefreshToken.substring(0, 8) + '...',\r\n          timestamp: new Date().toISOString()\r\n        }, ipAddress, userAgent)\r\n\r\n        return {\r\n          success: true,\r\n          newSessionToken,\r\n          newRefreshToken\r\n        }\r\n      }\r\n\r\n      return { success: false, reason: 'Token rotation disabled' }\r\n    } catch (error) {\r\n      console.error('Error refreshing session:', error)\r\n      return { success: false, reason: 'Session refresh failed' }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate a session\r\n   */\r\n  static async invalidateSession(\r\n    sessionToken: string,\r\n    userId?: string,\r\n    reason: string = 'manual_invalidation',\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ): Promise<{ success: boolean }> {\r\n    try {\r\n      const session = this.sessions.get(sessionToken)\r\n      \r\n      if (session) {\r\n        session.status = 'revoked'\r\n        this.sessions.set(sessionToken, session)\r\n      }\r\n\r\n      await SimpleAuditLogger.logSecurityEvent('PASSWORD_CHANGE', userId || 'system', {\r\n        action: 'session_invalidated',\r\n        reason,\r\n        sessionToken: sessionToken.substring(0, 8) + '...',\r\n        timestamp: new Date().toISOString()\r\n      }, ipAddress, userAgent)\r\n\r\n      return { success: true }\r\n    } catch (error) {\r\n      console.error('Error invalidating session:', error)\r\n      return { success: false }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate all sessions for a user\r\n   */\r\n  static async invalidateAllUserSessions(\r\n    userId: string,\r\n    reason: string = 'security_reason',\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ): Promise<{ success: boolean; invalidatedCount: number }> {\r\n    try {\r\n      let invalidatedCount = 0\r\n      \r\n      for (const [token, session] of this.sessions.entries()) {\r\n        if (session.userId === userId && session.status === 'active') {\r\n          session.status = 'revoked'\r\n          this.sessions.set(token, session)\r\n          invalidatedCount++\r\n        }\r\n      }\r\n\r\n      await SimpleAuditLogger.logSecurityEvent('PASSWORD_CHANGE', userId, {\r\n        action: 'all_sessions_invalidated',\r\n        reason,\r\n        invalidatedCount,\r\n        timestamp: new Date().toISOString()\r\n      }, ipAddress, userAgent)\r\n\r\n      return { success: true, invalidatedCount }\r\n    } catch (error) {\r\n      console.error('Error invalidating all sessions:', error)\r\n      return { success: false, invalidatedCount: 0 }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all active sessions for a user\r\n   */\r\n  static async getUserSessions(userId: string): Promise<SessionInfo[]> {\r\n    try {\r\n      return Array.from(this.sessions.values())\r\n        .filter(session => session.userId === userId)\r\n        .sort((a, b) => b.lastActivity.getTime() - a.lastActivity.getTime())\r\n    } catch (error) {\r\n      console.error('Error getting user sessions:', error)\r\n      return []\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up expired sessions\r\n   */\r\n  static async cleanupExpiredSessions(): Promise<number> {\r\n    try {\r\n      const now = new Date()\r\n      let cleanedCount = 0\r\n      \r\n      for (const [token, session] of this.sessions.entries()) {\r\n        if (session.expiresAt < now || session.status === 'expired') {\r\n          this.sessions.delete(token)\r\n          cleanedCount++\r\n        }\r\n      }\r\n      \r\n      return cleanedCount\r\n    } catch (error) {\r\n      console.error('Error cleaning up expired sessions:', error)\r\n      return 0\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enforce session limit per user\r\n   */\r\n  private static async enforceSessionLimit(userId: string): Promise<void> {\r\n    const userSessions = await this.getUserSessions(userId)\r\n    \r\n    if (userSessions.length >= this.config.maxConcurrentSessions) {\r\n      // Invalidate the oldest session\r\n      const oldestSession = userSessions.reduce((oldest, session) => \r\n        session.lastActivity < oldest.lastActivity ? session : oldest\r\n      )\r\n      \r\n      await this.invalidateSession(oldestSession.sessionToken, userId, 'concurrent_session_limit')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check for suspicious activity\r\n   */\r\n  static async checkSuspiciousActivity(\r\n    userId: string,\r\n    currentIpAddress: string,\r\n    currentUserAgent: string\r\n  ): Promise<{\r\n    suspicious: boolean\r\n    reasons: string[]\r\n  }> {\r\n    const reasons: string[] = []\r\n    let suspicious = false\r\n\r\n    try {\r\n      const sessions = await this.getUserSessions(userId)\r\n      \r\n      // Check for IP address changes\r\n      const ipAddresses = [...new Set(sessions.map(s => s.ipAddress))]\r\n      if (ipAddresses.length > 1 && !ipAddresses.includes(currentIpAddress)) {\r\n        reasons.push('Multiple IP addresses detected')\r\n        suspicious = true\r\n      }\r\n\r\n      // Check for new device/user agent\r\n      const userAgents = [...new Set(sessions.map(s => s.userAgent))]\r\n      if (userAgents.length > 1 && !userAgents.includes(currentUserAgent)) {\r\n        reasons.push('Multiple devices detected')\r\n        suspicious = true\r\n      }\r\n\r\n      // Check for rapid session creation\r\n      const recentSessions = sessions.filter(s => \r\n        Date.now() - s.createdAt.getTime() < 5 * 60 * 1000 // Last 5 minutes\r\n      )\r\n      if (recentSessions.length > this.config.maxConcurrentSessions) {\r\n        reasons.push('Rapid session creation detected')\r\n        suspicious = true\r\n      }\r\n\r\n      if (suspicious) {\r\n        await SimpleAuditLogger.logSecurityEvent('UNAUTHORIZED_ACCESS', userId, {\r\n          action: 'suspicious_activity',\r\n          reasons,\r\n          currentIpAddress,\r\n          currentUserAgent\r\n        }, currentIpAddress, currentUserAgent)\r\n      }\r\n\r\n      return { suspicious, reasons }\r\n    } catch (error) {\r\n      console.error('Error checking suspicious activity:', error)\r\n      return { suspicious: false, reasons: [] }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate secure random token\r\n   */\r\n  private static generateSecureToken(length: number): string {\r\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\r\n    let token = ''\r\n    \r\n    for (let i = 0; i < length; i++) {\r\n      token += chars.charAt(Math.floor(Math.random() * chars.length))\r\n    }\r\n    \r\n    return token\r\n  }\r\n\r\n  /**\r\n   * Get session statistics\r\n   */\r\n  static async getSessionStats(): Promise<{\r\n    totalSessions: number\r\n    activeSessions: number\r\n    expiredSessions: number\r\n    averageSessionDuration: number\r\n  }> {\r\n    try {\r\n      const sessions = Array.from(this.sessions.values())\r\n      const now = new Date()\r\n      \r\n      const activeSessions = sessions.filter(s => s.status === 'active' && s.expiresAt > now).length\r\n      const expiredSessions = sessions.filter(s => s.status === 'expired' || s.expiresAt <= now).length\r\n      \r\n      // Calculate average duration for active sessions\r\n      const activeSessionDurations = sessions\r\n        .filter(s => s.status === 'active')\r\n        .map(s => now.getTime() - s.createdAt.getTime())\r\n      \r\n      const averageSessionDuration = activeSessionDurations.length > 0\r\n        ? activeSessionDurations.reduce((sum, duration) => sum + duration, 0) / activeSessionDurations.length\r\n        : 0\r\n      \r\n      return {\r\n        totalSessions: sessions.length,\r\n        activeSessions,\r\n        expiredSessions,\r\n        averageSessionDuration: Math.round(averageSessionDuration / 1000 / 60) // Convert to minutes\r\n      }\r\n    } catch (error) {\r\n      console.error('Error getting session stats:', error)\r\n      return {\r\n        totalSessions: 0,\r\n        activeSessions: 0,\r\n        expiredSessions: 0,\r\n        averageSessionDuration: 0\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update configuration\r\n   */\r\n  static updateConfig(newConfig: Partial<SessionConfig>) {\r\n    this.config = { ...this.config, ...newConfig }\r\n  }\r\n\r\n  /**\r\n   * Get current configuration\r\n   */\r\n  static getConfig(): SessionConfig {\r\n    return { ...this.config }\r\n  }\r\n}\r\n\r\n// SessionConfig and SessionInfo are already exported above"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 501, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/lib/security/__tests__/sessionManager.test.ts"],"sourcesContent":["// Session Manager Integration Test\r\nimport { SessionManager } from \"../sessionManager\"\r\nimport { SimpleAuditLogger } from \"../simpleAuditLogger\"\r\n\r\n// Jest tests - only run in test environment\r\nif (typeof describe !== 'undefined') {\r\ndescribe('SessionManager Integration', () => {\r\n  beforeEach(() => {\r\n    // Clear any existing sessions before each test\r\n    // Note: In a real test environment, you'd have a way to reset the sessions Map\r\n  })\r\n\r\n  test('should create a session and log to audit system', async () => {\r\n    const userId = 'test-user-123'\r\n    const sessionToken = 'test-session-token'\r\n    const ipAddress = '192.168.1.1'\r\n    const userAgent = 'Mozilla/5.0 (Test Browser)'\r\n\r\n    // Create a session\r\n    const session = await SessionManager.createSession(\r\n      userId,\r\n      sessionToken,\r\n      undefined,\r\n      'Test Device',\r\n      ipAddress,\r\n      userAgent\r\n    )\r\n\r\n    // Verify session was created with correct properties\r\n    expect(session).toBeDefined()\r\n    expect(session.userId).toBe(userId)\r\n    expect(session.sessionToken).toBe(sessionToken)\r\n    expect(session.ipAddress).toBe(ipAddress)\r\n    expect(session.userAgent).toBe(userAgent)\r\n    expect(session.status).toBe('active')\r\n    expect(session.createdAt).toBeInstanceOf(Date)\r\n    expect(session.lastActivity).toBeInstanceOf(Date)\r\n    expect(session.expiresAt).toBeInstanceOf(Date)\r\n\r\n    console.log('‚úÖ Session created successfully:', session.id)\r\n  })\r\n\r\n  test('should validate a session successfully', async () => {\r\n    const userId = 'test-user-456'\r\n    const sessionToken = 'test-session-token-2'\r\n    const ipAddress = '192.168.1.2'\r\n\r\n    // First create a session\r\n    await SessionManager.createSession(userId, sessionToken, undefined, 'Test Device', ipAddress)\r\n\r\n    // Then validate it\r\n    const validation = await SessionManager.validateSession(sessionToken, ipAddress)\r\n\r\n    expect(validation.valid).toBe(true)\r\n    expect(validation.session).toBeDefined()\r\n    expect(validation.session?.userId).toBe(userId)\r\n    expect(validation.session?.sessionToken).toBe(sessionToken)\r\n\r\n    console.log('‚úÖ Session validation successful')\r\n  })\r\n\r\n  test('should handle session invalidation', async () => {\r\n    const userId = 'test-user-789'\r\n    const sessionToken = 'test-session-token-3'\r\n\r\n    // Create a session\r\n    await SessionManager.createSession(userId, sessionToken)\r\n\r\n    // Invalidate the session\r\n    const result = await SessionManager.invalidateSession(sessionToken, userId, 'test_invalidation')\r\n\r\n    expect(result.success).toBe(true)\r\n\r\n    // Try to validate the invalidated session\r\n    const validation = await SessionManager.validateSession(sessionToken)\r\n\r\n    expect(validation.valid).toBe(false)\r\n    expect(validation.reason).toContain('revoked')\r\n\r\n    console.log('‚úÖ Session invalidation successful')\r\n  })\r\n\r\n  test('should get user sessions', async () => {\r\n    const userId = 'test-user-sessions'\r\n    \r\n    // Create multiple sessions for the same user\r\n    await SessionManager.createSession(userId, 'token-1')\r\n    await SessionManager.createSession(userId, 'token-2')\r\n    await SessionManager.createSession(userId, 'token-3')\r\n\r\n    // Get user sessions\r\n    const sessions = await SessionManager.getUserSessions(userId)\r\n\r\n    expect(sessions).toHaveLength(3)\r\n    expect(sessions.every(s => s.userId === userId)).toBe(true)\r\n\r\n    console.log('‚úÖ User sessions retrieval successful:', sessions.length, 'sessions')\r\n  })\r\n\r\n  test('should provide session statistics', async () => {\r\n    // Create some test sessions\r\n    await SessionManager.createSession('user-1', 'token-1')\r\n    await SessionManager.createSession('user-2', 'token-2')\r\n\r\n    // Get stats\r\n    const stats = await SessionManager.getSessionStats()\r\n\r\n    expect(stats.totalSessions).toBeGreaterThanOrEqual(2)\r\n    expect(stats.activeSessions).toBeGreaterThanOrEqual(2)\r\n    expect(stats.averageSessionDuration).toBeGreaterThanOrEqual(0)\r\n\r\n    console.log('‚úÖ Session statistics:', stats)\r\n  })\r\n\r\n  test('should clean up expired sessions', async () => {\r\n    // Create a session that will expire quickly (1 second timeout)\r\n    const originalConfig = SessionManager.getConfig()\r\n    SessionManager.updateConfig({ sessionTimeout: 0.016 }) // ~1 second in minutes\r\n\r\n    const sessionToken = 'expiring-session'\r\n    await SessionManager.createSession('test-user', sessionToken)\r\n\r\n    // Wait for session to expire\r\n    await new Promise(resolve => setTimeout(resolve, 1100))\r\n\r\n    // Clean up expired sessions\r\n    const cleanedCount = await SessionManager.cleanupExpiredSessions()\r\n\r\n    expect(cleanedCount).toBeGreaterThanOrEqual(1)\r\n\r\n    // Restore original config\r\n    SessionManager.updateConfig(originalConfig)\r\n\r\n    console.log('‚úÖ Expired session cleanup successful, cleaned:', cleanedCount)\r\n  })\r\n})\r\n\r\n}\r\n\r\n// Manual test function for development\r\nexport async function manualSessionTest() {\r\n  console.log('üß™ Starting manual session manager test...')\r\n\r\n  try {\r\n    // Test 1: Create session\r\n    const session = await SessionManager.createSession(\r\n      'manual-test-user',\r\n      'manual-test-token',\r\n      'refresh-token-123',\r\n      'Test Device',\r\n      '127.0.0.1',\r\n      'Manual Test Browser'\r\n    )\r\n    console.log('‚úÖ Session created:', session.id)\r\n\r\n    // Test 2: Validate session\r\n    const validation = await SessionManager.validateSession('manual-test-token', '127.0.0.1')\r\n    console.log('‚úÖ Session validation:', validation.valid ? 'SUCCESS' : 'FAILED')\r\n\r\n    // Test 3: Get user sessions\r\n    const sessions = await SessionManager.getUserSessions('manual-test-user')\r\n    console.log('‚úÖ User sessions:', sessions.length)\r\n\r\n    // Test 4: Get stats\r\n    const stats = await SessionManager.getSessionStats()\r\n    console.log('‚úÖ Session stats:', stats)\r\n\r\n    // Test 5: Invalidate session\r\n    const invalidation = await SessionManager.invalidateSession('manual-test-token', 'manual-test-user', 'manual_test')\r\n    console.log('‚úÖ Session invalidation:', invalidation.success ? 'SUCCESS' : 'FAILED')\r\n\r\n    console.log('üéâ All manual tests completed successfully!')\r\n    return true\r\n  } catch (error) {\r\n    console.error('‚ùå Manual test failed:', error)\r\n    return false\r\n  }\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 633, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/app/api/test/session-manager/route.ts"],"sourcesContent":["// Test endpoint for Session Manager integration\r\nimport { NextRequest, NextResponse } from \"next/server\"\r\nimport { SessionManager } from \"@/lib/security/sessionManager\"\r\nimport { manualSessionTest } from \"@/lib/security/__tests__/sessionManager.test\"\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const { searchParams } = new URL(request.url)\r\n    const testType = searchParams.get('type') || 'basic'\r\n\r\n    console.log('üß™ Testing Session Manager:', testType)\r\n\r\n    let result\r\n\r\n    switch (testType) {\r\n      case 'basic':\r\n        // Basic session creation and validation test\r\n        const session = await SessionManager.createSession(\r\n          'test-user-' + Date.now(),\r\n          'test-token-' + Math.random().toString(36).substr(2, 9),\r\n          'refresh-token-' + Math.random().toString(36).substr(2, 9),\r\n          'Test Device',\r\n          '127.0.0.1',\r\n          'Test Browser'\r\n        )\r\n\r\n        const validation = await SessionManager.validateSession(session.sessionToken, '127.0.0.1')\r\n        \r\n        result = {\r\n          success: true,\r\n          test: 'basic',\r\n          session: {\r\n            id: session.id,\r\n            userId: session.userId,\r\n            status: session.status,\r\n            createdAt: session.createdAt,\r\n            expiresAt: session.expiresAt\r\n          },\r\n          validation: {\r\n            valid: validation.valid,\r\n            reason: validation.reason\r\n          }\r\n        }\r\n        break\r\n\r\n      case 'stats':\r\n        // Test session statistics\r\n        const stats = await SessionManager.getSessionStats()\r\n        result = {\r\n          success: true,\r\n          test: 'stats',\r\n          stats\r\n        }\r\n        break\r\n\r\n      case 'cleanup':\r\n        // Test session cleanup\r\n        const cleanedCount = await SessionManager.cleanupExpiredSessions()\r\n        result = {\r\n          success: true,\r\n          test: 'cleanup',\r\n          cleanedCount\r\n        }\r\n        break\r\n\r\n      case 'manual':\r\n        // Run comprehensive manual test\r\n        const manualResult = await manualSessionTest()\r\n        result = {\r\n          success: manualResult,\r\n          test: 'manual',\r\n          message: manualResult ? 'All manual tests passed' : 'Manual tests failed'\r\n        }\r\n        break\r\n\r\n      default:\r\n        result = {\r\n          success: false,\r\n          error: 'Unknown test type',\r\n          availableTests: ['basic', 'stats', 'cleanup', 'manual']\r\n        }\r\n    }\r\n\r\n    return NextResponse.json(result, { status: 200 })\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå Session Manager test failed:', error)\r\n    return NextResponse.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n      stack: error instanceof Error ? error.stack : undefined\r\n    }, { status: 500 })\r\n  }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = await request.json()\r\n    const { action, userId, sessionToken, ...options } = body\r\n\r\n    console.log('üß™ Session Manager Action:', action, 'for user:', userId)\r\n\r\n    let result\r\n\r\n    switch (action) {\r\n      case 'create':\r\n        const newSession = await SessionManager.createSession(\r\n          userId,\r\n          sessionToken,\r\n          options.refreshToken,\r\n          options.deviceInfo,\r\n          options.ipAddress,\r\n          options.userAgent\r\n        )\r\n        result = { success: true, session: newSession }\r\n        break\r\n\r\n      case 'validate':\r\n        const validation = await SessionManager.validateSession(\r\n          sessionToken,\r\n          options.ipAddress,\r\n          options.userAgent\r\n        )\r\n        result = { success: true, validation }\r\n        break\r\n\r\n      case 'invalidate':\r\n        const invalidation = await SessionManager.invalidateSession(\r\n          sessionToken,\r\n          userId,\r\n          options.reason || 'test_invalidation',\r\n          options.ipAddress,\r\n          options.userAgent\r\n        )\r\n        result = { success: true, invalidation }\r\n        break\r\n\r\n      case 'getUserSessions':\r\n        const sessions = await SessionManager.getUserSessions(userId)\r\n        result = { success: true, sessions }\r\n        break\r\n\r\n      case 'invalidateAll':\r\n        const allInvalidation = await SessionManager.invalidateAllUserSessions(\r\n          userId,\r\n          options.reason || 'test_invalidation_all',\r\n          options.ipAddress,\r\n          options.userAgent\r\n        )\r\n        result = { success: true, allInvalidation }\r\n        break\r\n\r\n      default:\r\n        result = {\r\n          success: false,\r\n          error: 'Unknown action',\r\n          availableActions: ['create', 'validate', 'invalidate', 'getUserSessions', 'invalidateAll']\r\n        }\r\n    }\r\n\r\n    return NextResponse.json(result, { status: 200 })\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå Session Manager action failed:', error)\r\n    return NextResponse.json({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n      stack: error instanceof Error ? error.stack : undefined\r\n    }, { status: 500 })\r\n  }\r\n}"],"names":[],"mappings":"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","debugId":null}}]
}