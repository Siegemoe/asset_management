{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client/edge';\r\nimport { withAccelerate } from '@prisma/extension-accelerate';\r\n\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma: ReturnType<typeof createPrismaClient> | undefined;\r\n};\r\n\r\nfunction createPrismaClient() {\r\n  const prisma = new PrismaClient({\r\n    datasources: {\r\n      db: {\r\n        url: process.env.DATABASE_URL!,\r\n      },\r\n    },\r\n  }).$extends(withAccelerate());\r\n  \r\n  return prisma;\r\n}\r\n\r\nexport const prisma = globalForPrisma.prisma ?? createPrismaClient();\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,MAAM,kBAAkB;AAIxB,SAAS;IACP,MAAM,SAAS,IAAI,6JAAY,CAAC;QAC9B,aAAa;YACX,IAAI;gBACF,KAAK,QAAQ,GAAG,CAAC,YAAY;YAC/B;QACF;IACF,GAAG,QAAQ,CAAC,IAAA,sLAAc;IAE1B,OAAO;AACT;AAEO,MAAM,SAAS,gBAAgB,MAAM,IAAI;AAEhD,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/lib/security/simpleAuditLogger.ts"],"sourcesContent":["// Simple Audit Logger - works with existing schema\r\n// import { prisma } from \"@/lib/prisma\" // Not used in current implementation\r\n\r\nexport interface AuditEvent {\r\n  id: string\r\n  userId?: string | undefined\r\n  action: string\r\n  resource?: string\r\n  details?: Record<string, any>\r\n  ipAddress?: string | undefined\r\n  userAgent?: string | undefined\r\n  severity?: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'\r\n  eventType?: string\r\n  description?: string\r\n  createdAt: Date\r\n}\r\n\r\n// In-memory store for audit events (in production, this would be a database)\r\n// Start with empty store - no placeholder data\r\nconst auditEventsStore: AuditEvent[] = []\r\n\r\nexport class SimpleAuditLogger {\r\n  private static generateId(): string {\r\n    return `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\r\n  }\r\n\r\n  /**\r\n   * Log a login attempt (both success and failure)\r\n   */\r\n  static async logLoginAttempt(\r\n    userId: string | undefined,\r\n    email: string,\r\n    success: boolean,\r\n    ipAddress?: string,\r\n    userAgent?: string,\r\n    reason?: string\r\n  ) {\r\n    try {\r\n      const event: AuditEvent = {\r\n        id: this.generateId(),\r\n        eventType: success ? 'LOGIN_SUCCESS' : 'LOGIN_FAILURE',\r\n        action: 'login',\r\n        description: success ? 'Successful login' : 'Failed login attempt',\r\n        userId,\r\n        severity: success ? 'LOW' : 'MEDIUM',\r\n        ipAddress,\r\n        userAgent,\r\n        createdAt: new Date()\r\n      }\r\n\r\n      auditEventsStore.unshift(event)\r\n      // Keep only the last 1000 events\r\n      if (auditEventsStore.length > 1000) {\r\n        auditEventsStore.splice(1000)\r\n      }\r\n\r\n      console.log('AUDIT:', event)\r\n    } catch (error) {\r\n      console.error('Failed to log login attempt:', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log logout\r\n   */\r\n  static async logLogout(\r\n    userId: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    const event: AuditEvent = {\r\n      id: this.generateId(),\r\n      eventType: 'LOGOUT',\r\n      action: 'logout',\r\n      description: 'User logout',\r\n      userId,\r\n      severity: 'LOW',\r\n      ipAddress,\r\n      userAgent,\r\n      createdAt: new Date()\r\n    }\r\n\r\n    auditEventsStore.unshift(event)\r\n    if (auditEventsStore.length > 1000) {\r\n      auditEventsStore.splice(1000)\r\n    }\r\n\r\n    console.log('AUDIT:', event)\r\n  }\r\n\r\n  /**\r\n   * Log data access\r\n   */\r\n  static async logDataAccess(\r\n    userId: string,\r\n    resource: string,\r\n    action: 'read' | 'list' | 'search',\r\n    resourceId?: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    const event: AuditEvent = {\r\n      id: this.generateId(),\r\n      eventType: 'DATA_ACCESS',\r\n      action: `${action}_${resource}`,\r\n      description: `User accessed ${resource} data`,\r\n      userId,\r\n      severity: 'LOW',\r\n      ipAddress,\r\n      userAgent,\r\n      createdAt: new Date()\r\n    }\r\n\r\n    auditEventsStore.unshift(event)\r\n    if (auditEventsStore.length > 1000) {\r\n      auditEventsStore.splice(1000)\r\n    }\r\n\r\n    console.log('AUDIT:', event)\r\n  }\r\n\r\n  /**\r\n   * Log data modification\r\n   */\r\n  static async logDataModification(\r\n    userId: string,\r\n    resource: string,\r\n    action: 'create' | 'update' | 'delete',\r\n    resourceId?: string,\r\n    changes?: Record<string, any>,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    const event: AuditEvent = {\r\n      id: this.generateId(),\r\n      eventType: 'DATA_MODIFICATION',\r\n      action: `${action}_${resource}`,\r\n      description: `User ${action}ed ${resource}`,\r\n      userId,\r\n      severity: action === 'delete' ? 'MEDIUM' : 'LOW',\r\n      ipAddress,\r\n      userAgent,\r\n      createdAt: new Date()\r\n    }\r\n\r\n    auditEventsStore.unshift(event)\r\n    if (auditEventsStore.length > 1000) {\r\n      auditEventsStore.splice(1000)\r\n    }\r\n\r\n    console.log('AUDIT:', event)\r\n  }\r\n\r\n  /**\r\n   * Log security events\r\n   */\r\n  static async logSecurityEvent(\r\n    event: 'ACCOUNT_LOCKED' | 'PASSWORD_CHANGE' | 'UNAUTHORIZED_ACCESS',\r\n    userId: string,\r\n    details: Record<string, any> = {},\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ) {\r\n    const auditEvent: AuditEvent = {\r\n      id: this.generateId(),\r\n      eventType: event,\r\n      action: 'security_event',\r\n      description: `${event} event occurred`,\r\n      userId,\r\n      severity: event === 'UNAUTHORIZED_ACCESS' ? 'HIGH' : 'MEDIUM',\r\n      details,\r\n      ipAddress,\r\n      userAgent,\r\n      createdAt: new Date()\r\n    }\r\n\r\n    auditEventsStore.unshift(auditEvent)\r\n    if (auditEventsStore.length > 1000) {\r\n      auditEventsStore.splice(1000)\r\n    }\r\n\r\n    console.log('SECURITY:', auditEvent)\r\n  }\r\n\r\n  /**\r\n   * Get recent events\r\n   */\r\n  static async getRecentEvents(limit: number = 100): Promise<AuditEvent[]> {\r\n    return auditEventsStore.slice(0, limit)\r\n  }\r\n\r\n  /**\r\n   * Get security events (high severity)\r\n   */\r\n  static async getSecurityEvents(limit: number = 50): Promise<AuditEvent[]> {\r\n    return auditEventsStore\r\n      .filter(event =>\r\n        event.severity === 'HIGH' ||\r\n        event.severity === 'CRITICAL' ||\r\n        event.eventType?.includes('SECURITY') ||\r\n        event.eventType === 'UNAUTHORIZED_ACCESS' ||\r\n        event.eventType === 'ACCOUNT_LOCKED'\r\n      )\r\n      .slice(0, limit)\r\n  }\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 222, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/lib/security/simpleAccountLockout.ts"],"sourcesContent":["// Simplified Account Lockout Service - works with current schema\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { SimpleAuditLogger } from \"./simpleAuditLogger\"\r\n\r\nexport interface LockoutConfig {\r\n  maxFailedAttempts: number\r\n  lockoutDuration: number // in minutes\r\n  progressiveLockout: boolean\r\n  maxLockoutDuration: number // in minutes\r\n}\r\n\r\nexport class SimpleAccountLockoutService {\r\n  private static config: LockoutConfig = {\r\n    maxFailedAttempts: 5,\r\n    lockoutDuration: 15, // 15 minutes\r\n    progressiveLockout: true,\r\n    maxLockoutDuration: 1440, // 24 hours\r\n  }\r\n\r\n  /**\r\n   * For now, we'll store lockout data in a separate table\r\n   * This approach works with the current schema\r\n   */\r\n  private static async recordFailedAttempt(\r\n    userId: string,\r\n    email: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ): Promise<void> {\r\n    // For now, we'll use a simple approach with a file-based storage or memory\r\n    // In production, you might want to add a simple table to the existing schema\r\n    console.log('FAILED_LOGIN_ATTEMPT:', {\r\n      userId,\r\n      email,\r\n      timestamp: new Date().toISOString(),\r\n      ipAddress,\r\n      userAgent\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Record a login attempt and determine if account should be locked\r\n   */\r\n  static async recordLoginAttempt(\r\n    userId: string | undefined,\r\n    email: string,\r\n    success: boolean,\r\n    ipAddress?: string,\r\n    userAgent?: string,\r\n    reason?: string\r\n  ): Promise<{\r\n    success: boolean\r\n    shouldLock: boolean\r\n    lockoutUntil?: Date\r\n    reason?: string\r\n  }> {\r\n    await SimpleAuditLogger.logLoginAttempt(userId, email, success, ipAddress, userAgent, reason)\r\n\r\n    if (success) {\r\n      return { success: true, shouldLock: false }\r\n    }\r\n\r\n    if (!userId) {\r\n      return { success: false, shouldLock: false, reason: \"User not found\" }\r\n    }\r\n\r\n    // Record the failed attempt\r\n    await this.recordFailedAttempt(userId, email, ipAddress, userAgent)\r\n\r\n    // For now, we'll implement a simple lockout check\r\n    // This would be enhanced once we have the proper Prisma client\r\n    const recentFailures = await this.getRecentFailedAttempts(userId, 15) // Last 15 minutes\r\n\r\n    if (recentFailures >= this.config.maxFailedAttempts) {\r\n      return {\r\n        success: false,\r\n        shouldLock: true,\r\n        lockoutUntil: new Date(Date.now() + this.config.lockoutDuration * 60 * 1000),\r\n        reason: `Account locked for ${this.config.lockoutDuration} minutes due to multiple failed attempts`,\r\n      }\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      shouldLock: false,\r\n      reason: `Invalid credentials (${recentFailures + 1}/${this.config.maxFailedAttempts} recent attempts)`,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get number of recent failed attempts for a user\r\n   */\r\n  private static async getRecentFailedAttempts(userId: string, minutes: number): Promise<number> {\r\n    // This is a simplified implementation\r\n    // In the full implementation, this would query the UserLoginAttempt table\r\n    const cutoffTime = new Date(Date.now() - minutes * 60 * 1000)\r\n    \r\n    // For now, return a mock value\r\n    // In production, this would query the database\r\n    return 0\r\n  }\r\n\r\n  /**\r\n   * Check if a user account is currently locked\r\n   * For now, we'll implement a simple check\r\n   */\r\n  static async isAccountLocked(userId: string): Promise<{\r\n    locked: boolean\r\n    lockoutUntil?: Date\r\n  }> {\r\n    // This would be enhanced once we have the proper Prisma client\r\n    // For now, return false (no lockout)\r\n    return { locked: false }\r\n  }\r\n\r\n  /**\r\n   * Unlock an account manually\r\n   */\r\n  static async unlockAccount(\r\n    userId: string,\r\n    unlockedBy: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ): Promise<{ success: boolean; message: string }> {\r\n    try {\r\n      // This would clear the lockout data\r\n      await SimpleAuditLogger.logSecurityEvent('PASSWORD_CHANGE', userId, { \r\n        action: 'unlock_account',\r\n        unlockedBy \r\n      }, ipAddress, userAgent)\r\n      \r\n      return { success: true, message: \"Account unlocked successfully\" }\r\n    } catch (error) {\r\n      return { success: false, message: \"Failed to unlock account\" }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get account lockout status and statistics\r\n   */\r\n  static async getLockoutStatus(userId: string) {\r\n    return {\r\n      isLocked: false,\r\n      recentFailedAttempts: 0,\r\n      maxAttempts: this.config.maxFailedAttempts,\r\n      config: this.config\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update lockout configuration\r\n   */\r\n  static updateConfig(newConfig: Partial<LockoutConfig>) {\r\n    this.config = { ...this.config, ...newConfig }\r\n  }\r\n\r\n  /**\r\n   * Get current configuration\r\n   */\r\n  static getConfig(): LockoutConfig {\r\n    return { ...this.config }\r\n  }\r\n}"],"names":[],"mappings":"AAAA,iEAAiE;;;;;AAEjE;;AASO,MAAM;IACX,OAAe,SAAwB;QACrC,mBAAmB;QACnB,iBAAiB;QACjB,oBAAoB;QACpB,oBAAoB;IACtB,EAAC;IAED;;;GAGC,GACD,aAAqB,oBACnB,MAAc,EACd,KAAa,EACb,SAAkB,EAClB,SAAkB,EACH;QACf,2EAA2E;QAC3E,6EAA6E;QAC7E,QAAQ,GAAG,CAAC,yBAAyB;YACnC;YACA;YACA,WAAW,IAAI,OAAO,WAAW;YACjC;YACA;QACF;IACF;IAEA;;GAEC,GACD,aAAa,mBACX,MAA0B,EAC1B,KAAa,EACb,OAAgB,EAChB,SAAkB,EAClB,SAAkB,EAClB,MAAe,EAMd;QACD,MAAM,gKAAiB,CAAC,eAAe,CAAC,QAAQ,OAAO,SAAS,WAAW,WAAW;QAEtF,IAAI,SAAS;YACX,OAAO;gBAAE,SAAS;gBAAM,YAAY;YAAM;QAC5C;QAEA,IAAI,CAAC,QAAQ;YACX,OAAO;gBAAE,SAAS;gBAAO,YAAY;gBAAO,QAAQ;YAAiB;QACvE;QAEA,4BAA4B;QAC5B,MAAM,IAAI,CAAC,mBAAmB,CAAC,QAAQ,OAAO,WAAW;QAEzD,kDAAkD;QAClD,+DAA+D;QAC/D,MAAM,iBAAiB,MAAM,IAAI,CAAC,uBAAuB,CAAC,QAAQ,IAAI,kBAAkB;;QAExF,IAAI,kBAAkB,IAAI,CAAC,MAAM,CAAC,iBAAiB,EAAE;YACnD,OAAO;gBACL,SAAS;gBACT,YAAY;gBACZ,cAAc,IAAI,KAAK,KAAK,GAAG,KAAK,IAAI,CAAC,MAAM,CAAC,eAAe,GAAG,KAAK;gBACvE,QAAQ,CAAC,mBAAmB,EAAE,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,wCAAwC,CAAC;YACrG;QACF;QAEA,OAAO;YACL,SAAS;YACT,YAAY;YACZ,QAAQ,CAAC,qBAAqB,EAAE,iBAAiB,EAAE,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,iBAAiB,CAAC;QACxG;IACF;IAEA;;GAEC,GACD,aAAqB,wBAAwB,MAAc,EAAE,OAAe,EAAmB;QAC7F,sCAAsC;QACtC,0EAA0E;QAC1E,MAAM,aAAa,IAAI,KAAK,KAAK,GAAG,KAAK,UAAU,KAAK;QAExD,+BAA+B;QAC/B,+CAA+C;QAC/C,OAAO;IACT;IAEA;;;GAGC,GACD,aAAa,gBAAgB,MAAc,EAGxC;QACD,+DAA+D;QAC/D,qCAAqC;QACrC,OAAO;YAAE,QAAQ;QAAM;IACzB;IAEA;;GAEC,GACD,aAAa,cACX,MAAc,EACd,UAAkB,EAClB,SAAkB,EAClB,SAAkB,EAC8B;QAChD,IAAI;YACF,oCAAoC;YACpC,MAAM,gKAAiB,CAAC,gBAAgB,CAAC,mBAAmB,QAAQ;gBAClE,QAAQ;gBACR;YACF,GAAG,WAAW;YAEd,OAAO;gBAAE,SAAS;gBAAM,SAAS;YAAgC;QACnE,EAAE,OAAO,OAAO;YACd,OAAO;gBAAE,SAAS;gBAAO,SAAS;YAA2B;QAC/D;IACF;IAEA;;GAEC,GACD,aAAa,iBAAiB,MAAc,EAAE;QAC5C,OAAO;YACL,UAAU;YACV,sBAAsB;YACtB,aAAa,IAAI,CAAC,MAAM,CAAC,iBAAiB;YAC1C,QAAQ,IAAI,CAAC,MAAM;QACrB;IACF;IAEA;;GAEC,GACD,OAAO,aAAa,SAAiC,EAAE;QACrD,IAAI,CAAC,MAAM,GAAG;YAAE,GAAG,IAAI,CAAC,MAAM;YAAE,GAAG,SAAS;QAAC;IAC/C;IAEA;;GAEC,GACD,OAAO,YAA2B;QAChC,OAAO;YAAE,GAAG,IAAI,CAAC,MAAM;QAAC;IAC1B;AACF","debugId":null}},
    {"offset": {"line": 357, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/lib/security/sessionManager.ts"],"sourcesContent":["// Enhanced Session Management Service\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { SimpleAuditLogger } from \"./simpleAuditLogger\"\r\n\r\nexport interface SessionConfig {\r\n  sessionTimeout: number // in minutes\r\n  maxConcurrentSessions: number\r\n  refreshTokenRotation: boolean\r\n  requireHTTPS: boolean\r\n  sessionFingerprinting: boolean\r\n}\r\n\r\nexport interface SessionInfo {\r\n  id: string\r\n  userId: string\r\n  sessionToken: string\r\n  refreshToken: string | undefined\r\n  deviceInfo: string | undefined\r\n  ipAddress: string | undefined\r\n  userAgent: string | undefined\r\n  createdAt: Date\r\n  lastActivity: Date\r\n  expiresAt: Date\r\n  status: 'active' | 'expired' | 'revoked'\r\n}\r\n\r\nexport class SessionManager {\r\n  private static config: SessionConfig = {\r\n    sessionTimeout: 30, // 30 minutes\r\n    maxConcurrentSessions: 3,\r\n    refreshTokenRotation: true,\r\n    requireHTTPS: true,\r\n    sessionFingerprinting: true,\r\n  }\r\n\r\n  // In-memory session storage (in production, this would be a database)\r\n  private static sessions: Map<string, SessionInfo> = new Map()\r\n\r\n  /**\r\n   * Create a new session\r\n   */\r\n  static async createSession(\r\n    userId: string,\r\n    sessionToken: string,\r\n    refreshToken?: string,\r\n    deviceInfo?: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ): Promise<SessionInfo> {\r\n    // Check concurrent session limit\r\n    await this.enforceSessionLimit(userId)\r\n\r\n    const expiresAt = new Date(Date.now() + this.config.sessionTimeout * 60 * 1000)\r\n\r\n    const now = new Date()\r\n    const sessionInfo: SessionInfo = {\r\n      id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n      userId,\r\n      sessionToken,\r\n      refreshToken: refreshToken || undefined,\r\n      deviceInfo: deviceInfo || undefined,\r\n      ipAddress: ipAddress || undefined,\r\n      userAgent: userAgent || undefined,\r\n      createdAt: now,\r\n      lastActivity: now,\r\n      expiresAt,\r\n      status: 'active'\r\n    }\r\n\r\n    // Store session in memory\r\n    this.sessions.set(sessionToken, sessionInfo)\r\n\r\n    // Log session creation\r\n    await SimpleAuditLogger.logSecurityEvent('PASSWORD_CHANGE', userId, {\r\n      action: 'session_created',\r\n      sessionId: sessionInfo.id,\r\n      deviceInfo,\r\n      timestamp: new Date().toISOString()\r\n    }, ipAddress, userAgent)\r\n\r\n    // In a real implementation, you would store this in the database\r\n    console.log('SESSION_CREATED:', sessionInfo)\r\n\r\n    return sessionInfo\r\n  }\r\n\r\n  /**\r\n   * Validate and refresh session\r\n   */\r\n  static async validateSession(sessionToken: string, ipAddress?: string, userAgent?: string): Promise<{\r\n    valid: boolean\r\n    session?: SessionInfo\r\n    reason?: string\r\n  }> {\r\n    try {\r\n      const session = this.sessions.get(sessionToken)\r\n      \r\n      if (!session) {\r\n        return { valid: false, reason: 'Session not found' }\r\n      }\r\n\r\n      if (session.expiresAt < new Date()) {\r\n        session.status = 'expired'\r\n        this.sessions.set(sessionToken, session)\r\n        return { valid: false, reason: 'Session expired' }\r\n      }\r\n\r\n      if (session.status !== 'active') {\r\n        return { valid: false, reason: `Session ${session.status}` }\r\n      }\r\n\r\n      // Update last activity\r\n      session.lastActivity = new Date()\r\n      this.sessions.set(sessionToken, session)\r\n\r\n      return { valid: true, session }\r\n    } catch (error) {\r\n      console.error('Error validating session:', error)\r\n      return { valid: false, reason: 'Session validation failed' }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Refresh session token\r\n   */\r\n  static async refreshSession(\r\n    refreshToken: string,\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ): Promise<{\r\n    success: boolean\r\n    newSessionToken?: string\r\n    newRefreshToken?: string\r\n    reason?: string\r\n  }> {\r\n    try {\r\n      if (this.config.refreshTokenRotation) {\r\n        // Generate new tokens\r\n        const newSessionToken = this.generateSecureToken(32)\r\n        const newRefreshToken = this.generateSecureToken(32)\r\n\r\n        await SimpleAuditLogger.logSecurityEvent('PASSWORD_CHANGE', 'system', {\r\n          action: 'session_refreshed',\r\n          oldRefreshToken: refreshToken.substring(0, 8) + '...',\r\n          newRefreshToken: newRefreshToken.substring(0, 8) + '...',\r\n          timestamp: new Date().toISOString()\r\n        }, ipAddress, userAgent)\r\n\r\n        return {\r\n          success: true,\r\n          newSessionToken,\r\n          newRefreshToken\r\n        }\r\n      }\r\n\r\n      return { success: false, reason: 'Token rotation disabled' }\r\n    } catch (error) {\r\n      console.error('Error refreshing session:', error)\r\n      return { success: false, reason: 'Session refresh failed' }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate a session\r\n   */\r\n  static async invalidateSession(\r\n    sessionToken: string,\r\n    userId?: string,\r\n    reason: string = 'manual_invalidation',\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ): Promise<{ success: boolean }> {\r\n    try {\r\n      const session = this.sessions.get(sessionToken)\r\n      \r\n      if (session) {\r\n        session.status = 'revoked'\r\n        this.sessions.set(sessionToken, session)\r\n      }\r\n\r\n      await SimpleAuditLogger.logSecurityEvent('PASSWORD_CHANGE', userId || 'system', {\r\n        action: 'session_invalidated',\r\n        reason,\r\n        sessionToken: sessionToken.substring(0, 8) + '...',\r\n        timestamp: new Date().toISOString()\r\n      }, ipAddress, userAgent)\r\n\r\n      return { success: true }\r\n    } catch (error) {\r\n      console.error('Error invalidating session:', error)\r\n      return { success: false }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate all sessions for a user\r\n   */\r\n  static async invalidateAllUserSessions(\r\n    userId: string,\r\n    reason: string = 'security_reason',\r\n    ipAddress?: string,\r\n    userAgent?: string\r\n  ): Promise<{ success: boolean; invalidatedCount: number }> {\r\n    try {\r\n      let invalidatedCount = 0\r\n      \r\n      for (const [token, session] of this.sessions.entries()) {\r\n        if (session.userId === userId && session.status === 'active') {\r\n          session.status = 'revoked'\r\n          this.sessions.set(token, session)\r\n          invalidatedCount++\r\n        }\r\n      }\r\n\r\n      await SimpleAuditLogger.logSecurityEvent('PASSWORD_CHANGE', userId, {\r\n        action: 'all_sessions_invalidated',\r\n        reason,\r\n        invalidatedCount,\r\n        timestamp: new Date().toISOString()\r\n      }, ipAddress, userAgent)\r\n\r\n      return { success: true, invalidatedCount }\r\n    } catch (error) {\r\n      console.error('Error invalidating all sessions:', error)\r\n      return { success: false, invalidatedCount: 0 }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all active sessions for a user\r\n   */\r\n  static async getUserSessions(userId: string): Promise<SessionInfo[]> {\r\n    try {\r\n      return Array.from(this.sessions.values())\r\n        .filter(session => session.userId === userId)\r\n        .sort((a, b) => b.lastActivity.getTime() - a.lastActivity.getTime())\r\n    } catch (error) {\r\n      console.error('Error getting user sessions:', error)\r\n      return []\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up expired sessions\r\n   */\r\n  static async cleanupExpiredSessions(): Promise<number> {\r\n    try {\r\n      const now = new Date()\r\n      let cleanedCount = 0\r\n      \r\n      for (const [token, session] of this.sessions.entries()) {\r\n        if (session.expiresAt < now || session.status === 'expired') {\r\n          this.sessions.delete(token)\r\n          cleanedCount++\r\n        }\r\n      }\r\n      \r\n      return cleanedCount\r\n    } catch (error) {\r\n      console.error('Error cleaning up expired sessions:', error)\r\n      return 0\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enforce session limit per user\r\n   */\r\n  private static async enforceSessionLimit(userId: string): Promise<void> {\r\n    const userSessions = await this.getUserSessions(userId)\r\n    \r\n    if (userSessions.length >= this.config.maxConcurrentSessions) {\r\n      // Invalidate the oldest session\r\n      const oldestSession = userSessions.reduce((oldest, session) => \r\n        session.lastActivity < oldest.lastActivity ? session : oldest\r\n      )\r\n      \r\n      await this.invalidateSession(oldestSession.sessionToken, userId, 'concurrent_session_limit')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check for suspicious activity\r\n   */\r\n  static async checkSuspiciousActivity(\r\n    userId: string,\r\n    currentIpAddress: string,\r\n    currentUserAgent: string\r\n  ): Promise<{\r\n    suspicious: boolean\r\n    reasons: string[]\r\n  }> {\r\n    const reasons: string[] = []\r\n    let suspicious = false\r\n\r\n    try {\r\n      const sessions = await this.getUserSessions(userId)\r\n      \r\n      // Check for IP address changes\r\n      const ipAddresses = [...new Set(sessions.map(s => s.ipAddress))]\r\n      if (ipAddresses.length > 1 && !ipAddresses.includes(currentIpAddress)) {\r\n        reasons.push('Multiple IP addresses detected')\r\n        suspicious = true\r\n      }\r\n\r\n      // Check for new device/user agent\r\n      const userAgents = [...new Set(sessions.map(s => s.userAgent))]\r\n      if (userAgents.length > 1 && !userAgents.includes(currentUserAgent)) {\r\n        reasons.push('Multiple devices detected')\r\n        suspicious = true\r\n      }\r\n\r\n      // Check for rapid session creation\r\n      const recentSessions = sessions.filter(s => \r\n        Date.now() - s.createdAt.getTime() < 5 * 60 * 1000 // Last 5 minutes\r\n      )\r\n      if (recentSessions.length > this.config.maxConcurrentSessions) {\r\n        reasons.push('Rapid session creation detected')\r\n        suspicious = true\r\n      }\r\n\r\n      if (suspicious) {\r\n        await SimpleAuditLogger.logSecurityEvent('UNAUTHORIZED_ACCESS', userId, {\r\n          action: 'suspicious_activity',\r\n          reasons,\r\n          currentIpAddress,\r\n          currentUserAgent\r\n        }, currentIpAddress, currentUserAgent)\r\n      }\r\n\r\n      return { suspicious, reasons }\r\n    } catch (error) {\r\n      console.error('Error checking suspicious activity:', error)\r\n      return { suspicious: false, reasons: [] }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate secure random token\r\n   */\r\n  private static generateSecureToken(length: number): string {\r\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\r\n    let token = ''\r\n    \r\n    for (let i = 0; i < length; i++) {\r\n      token += chars.charAt(Math.floor(Math.random() * chars.length))\r\n    }\r\n    \r\n    return token\r\n  }\r\n\r\n  /**\r\n   * Get session statistics\r\n   */\r\n  static async getSessionStats(): Promise<{\r\n    totalSessions: number\r\n    activeSessions: number\r\n    expiredSessions: number\r\n    averageSessionDuration: number\r\n  }> {\r\n    try {\r\n      const sessions = Array.from(this.sessions.values())\r\n      const now = new Date()\r\n      \r\n      const activeSessions = sessions.filter(s => s.status === 'active' && s.expiresAt > now).length\r\n      const expiredSessions = sessions.filter(s => s.status === 'expired' || s.expiresAt <= now).length\r\n      \r\n      // Calculate average duration for active sessions\r\n      const activeSessionDurations = sessions\r\n        .filter(s => s.status === 'active')\r\n        .map(s => now.getTime() - s.createdAt.getTime())\r\n      \r\n      const averageSessionDuration = activeSessionDurations.length > 0\r\n        ? activeSessionDurations.reduce((sum, duration) => sum + duration, 0) / activeSessionDurations.length\r\n        : 0\r\n      \r\n      return {\r\n        totalSessions: sessions.length,\r\n        activeSessions,\r\n        expiredSessions,\r\n        averageSessionDuration: Math.round(averageSessionDuration / 1000 / 60) // Convert to minutes\r\n      }\r\n    } catch (error) {\r\n      console.error('Error getting session stats:', error)\r\n      return {\r\n        totalSessions: 0,\r\n        activeSessions: 0,\r\n        expiredSessions: 0,\r\n        averageSessionDuration: 0\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update configuration\r\n   */\r\n  static updateConfig(newConfig: Partial<SessionConfig>) {\r\n    this.config = { ...this.config, ...newConfig }\r\n  }\r\n\r\n  /**\r\n   * Get current configuration\r\n   */\r\n  static getConfig(): SessionConfig {\r\n    return { ...this.config }\r\n  }\r\n}\r\n\r\n// SessionConfig and SessionInfo are already exported above"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 679, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/lib/security/securityMiddleware.ts"],"sourcesContent":["// Security Middleware and Utilities\r\nimport { NextRequest } from \"next/server\"\r\nimport bcrypt from 'bcryptjs'\r\n// import crypto from \"crypto\" // Not compatible with Edge Runtime\r\n\r\nexport interface RateLimitConfig {\r\n  windowMs: number // Time window in milliseconds\r\n  max: number // Max requests per window\r\n  message?: string\r\n  skipSuccessfulRequests?: boolean\r\n  skipFailedRequests?: boolean\r\n}\r\n\r\nexport class SecurityMiddleware {\r\n  private static rateLimitStore = new Map<string, { count: number; resetTime: number }>()\r\n\r\n  /**\r\n   * Rate limiting middleware\r\n   */\r\n  static rateLimit(\r\n    identifier: string,\r\n    config: RateLimitConfig\r\n  ): { allowed: boolean; remaining: number; resetTime: number; message?: string } {\r\n    const key = `rate_limit:${identifier}`\r\n    const now = Date.now()\r\n    \r\n    const current = this.rateLimitStore.get(key)\r\n    \r\n    if (!current || now > current.resetTime) {\r\n      // Reset or initialize\r\n      this.rateLimitStore.set(key, {\r\n        count: 1,\r\n        resetTime: now + config.windowMs\r\n      })\r\n      return {\r\n        allowed: true,\r\n        remaining: config.max - 1,\r\n        resetTime: now + config.windowMs\r\n      }\r\n    }\r\n    \r\n    if (current.count >= config.max) {\r\n      return {\r\n        allowed: false,\r\n        remaining: 0,\r\n        resetTime: current.resetTime,\r\n        message: config.message || `Rate limit exceeded. Try again in ${Math.ceil((current.resetTime - now) / 1000)} seconds.`\r\n      }\r\n    }\r\n    \r\n    // Increment counter\r\n    current.count++\r\n    this.rateLimitStore.set(key, current)\r\n    \r\n    return {\r\n      allowed: true,\r\n      remaining: config.max - current.count,\r\n      resetTime: current.resetTime\r\n    }\r\n  }\r\n\r\n  /**\r\n   * CSRF Protection\r\n   */\r\n  static generateCSRFToken(): string {\r\n    // Use Web Crypto API for Edge Runtime compatibility\r\n    const array = new Uint8Array(32)\r\n    crypto.getRandomValues(array)\r\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('')\r\n  }\r\n\r\n  static verifyCSRFToken(request: NextRequest): { valid: boolean; reason?: string } {\r\n    try {\r\n      const csrfToken = request.headers.get('x-csrf-token')\r\n      const origin = request.headers.get('origin')\r\n      const referer = request.headers.get('referer')\r\n      \r\n      if (!csrfToken) {\r\n        return { valid: false, reason: 'CSRF token missing' }\r\n      }\r\n      \r\n      // Check if token format is valid\r\n      if (!/^[a-f0-9]{64}$/.test(csrfToken)) {\r\n        return { valid: false, reason: 'Invalid CSRF token format' }\r\n      }\r\n      \r\n      // In production, you would also verify against stored tokens\r\n      // For now, we'll use a simple validation approach\r\n      \r\n      return { valid: true }\r\n    } catch (error) {\r\n      return { valid: false, reason: 'CSRF validation error' }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate request origin\r\n   */\r\n  static validateOrigin(\r\n    request: NextRequest,\r\n    allowedOrigins: string[]\r\n  ): { valid: boolean; reason?: string } {\r\n    const origin = request.headers.get('origin')\r\n    const referer = request.headers.get('referer')\r\n    \r\n    if (!origin && !referer) {\r\n      // Allow requests without origin (e.g., mobile apps, API clients)\r\n      return { valid: true }\r\n    }\r\n    \r\n    const requestOrigin = origin || referer\r\n    if (!requestOrigin) {\r\n      return { valid: false, reason: 'No origin or referer header' }\r\n    }\r\n    \r\n    const hostname = new URL(requestOrigin).hostname\r\n    const isAllowed = allowedOrigins.some(allowed => {\r\n      if (allowed === hostname) return true\r\n      if (allowed.startsWith('*.')) {\r\n        return hostname.endsWith(allowed.substring(2))\r\n      }\r\n      return false\r\n    })\r\n    \r\n    return {\r\n      valid: isAllowed,\r\n      reason: isAllowed ? undefined : `Origin ${hostname} not allowed`\r\n    } as { valid: boolean; reason?: string }\r\n  }\r\n\r\n  /**\r\n   * Security headers middleware\r\n   */\r\n  static getSecurityHeaders(): Record<string, string> {\r\n    return {\r\n      // Prevent clickjacking\r\n      'X-Frame-Options': 'DENY',\r\n      // Prevent MIME type sniffing\r\n      'X-Content-Type-Options': 'nosniff',\r\n      // Enable XSS protection\r\n      'X-XSS-Protection': '1; mode=block',\r\n      // Force HTTPS\r\n      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',\r\n      // Referrer policy\r\n      'Referrer-Policy': 'strict-origin-when-cross-origin',\r\n      // Content Security Policy (basic)\r\n      'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self';\",\r\n      // Permissions Policy\r\n      'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Input sanitization utilities\r\n   */\r\n  static sanitizeString(input: string, maxLength?: number): string {\r\n    if (typeof input !== 'string') {\r\n      return ''\r\n    }\r\n    \r\n    let sanitized = input\r\n      .trim()\r\n      .replace(/[\\x00-\\x1F\\x7F]/g, '') // Remove control characters\r\n      .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '') // Remove script tags\r\n      .replace(/<[^>]*>/g, '') // Remove HTML tags\r\n      .replace(/javascript:/gi, '') // Remove javascript: protocol\r\n      .replace(/data:/gi, '') // Remove data: protocol\r\n      .replace(/vbscript:/gi, '') // Remove vbscript: protocol\r\n    \r\n    if (maxLength && sanitized.length > maxLength) {\r\n      sanitized = sanitized.substring(0, maxLength)\r\n    }\r\n    \r\n    return sanitized\r\n  }\r\n\r\n  static sanitizeEmail(email: string): string {\r\n    const sanitized = this.sanitizeString(email, 254)\r\n    // Basic email validation\r\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\r\n    return emailRegex.test(sanitized) ? sanitized.toLowerCase() : ''\r\n  }\r\n\r\n  static sanitizeUrl(url: string): string {\r\n    const sanitized = this.sanitizeString(url, 2048)\r\n    try {\r\n      const parsed = new URL(sanitized)\r\n      // Only allow http and https protocols\r\n      if (!['http:', 'https:'].includes(parsed.protocol)) {\r\n        return ''\r\n      }\r\n      return parsed.toString()\r\n    } catch {\r\n      return ''\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Password strength validation\r\n   */\r\n  static validatePasswordStrength(password: string): {\r\n    score: number\r\n    feedback: string[]\r\n    valid: boolean\r\n  } {\r\n    const feedback: string[] = []\r\n    let score = 0\r\n\r\n    // Length\r\n    if (password.length >= 8) score += 20\r\n    if (password.length >= 12) score += 20\r\n    if (password.length >= 16) score += 10\r\n\r\n    // Character types\r\n    if (/[a-z]/.test(password)) score += 10\r\n    if (/[A-Z]/.test(password)) score += 10\r\n    if (/\\d/.test(password)) score += 10\r\n    if (/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/.test(password)) score += 10\r\n\r\n    // Patterns\r\n    if (/(.)\\1{2,}/.test(password)) score -= 10 // Penalize repeated characters\r\n    if (/123|abc|qwe|asd/i.test(password)) score -= 15 // Penalize common patterns\r\n\r\n    // Feedback\r\n    if (password.length < 8) feedback.push('Password must be at least 8 characters long')\r\n    if (!/[a-z]/.test(password)) feedback.push('Include lowercase letters')\r\n    if (!/[A-Z]/.test(password)) feedback.push('Include uppercase letters')\r\n    if (!/\\d/.test(password)) feedback.push('Include numbers')\r\n    if (!/[!@#$%^&*]/.test(password)) feedback.push('Include special characters')\r\n    if (/(.)\\1{2,}/.test(password)) feedback.push('Avoid repeated characters')\r\n    if (/123|abc|qwe|asd/i.test(password)) feedback.push('Avoid common patterns')\r\n\r\n    const valid = score >= 40 && feedback.length === 0\r\n\r\n    return {\r\n      score: Math.max(0, Math.min(100, score)),\r\n      feedback,\r\n      valid\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate secure random string\r\n   */\r\n  static generateSecureRandomString(length: number, charset?: string): string {\r\n    const defaultCharset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\r\n    const chars = charset || defaultCharset\r\n    let result = ''\r\n    \r\n    // Use Web Crypto API for Edge Runtime compatibility\r\n    const randomValues = new Uint8Array(length)\r\n    crypto.getRandomValues(randomValues)\r\n    \r\n    for (let i = 0; i < length; i++) {\r\n      result += chars.charAt((randomValues[i] || 0) % chars.length)\r\n    }\r\n    \r\n    return result\r\n  }\r\n\r\n  /**\r\n   * Hash data with salt\r\n   */\r\n  static async hashWithSalt(data: string, salt?: string): Promise<{ hash: string; salt: string }> {\r\n    // Use bcryptjs for password hashing (Edge Runtime compatible)\r\n    const saltRounds = 12\r\n    const actualSalt = salt || await bcrypt.genSalt(saltRounds)\r\n    const hash = await bcrypt.hash(data, actualSalt)\r\n    return { hash, salt: actualSalt }\r\n  }\r\n\r\n  /**\r\n   * Verify hash\r\n   */\r\n  static async verifyHash(data: string, hash: string, salt: string): Promise<boolean> {\r\n    // Use bcryptjs for password verification (Edge Runtime compatible)\r\n    return await bcrypt.compare(data, hash)\r\n  }\r\n\r\n  /**\r\n   * Detect suspicious patterns\r\n   */\r\n  static detectSuspiciousPatterns(input: string): {\r\n    suspicious: boolean\r\n    patterns: string[]\r\n  } {\r\n    const patterns: string[] = []\r\n    \r\n    // SQL injection patterns\r\n    const sqlPatterns = [\r\n      /(\\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\\b)/gi,\r\n      /('|(\\\\)|(--|#|\\/\\*))/gi,\r\n      /((\\%27)|(\\'))((\\%6F)|o|(\\%4F))((\\%72)|r|(\\%52))/gi,\r\n    ]\r\n    \r\n    // XSS patterns\r\n    const xssPatterns = [\r\n      /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\r\n      /<iframe\\b[^<]*(?:(?!<\\/iframe>)<[^<]*)*<\\/iframe>/gi,\r\n      /javascript:/gi,\r\n      /on\\w+\\s*=/gi\r\n    ]\r\n    \r\n    // Path traversal patterns\r\n    const pathPatterns = [\r\n      /\\.\\./g,\r\n      /[\\\\/]/g\r\n    ]\r\n    \r\n    // Command injection patterns\r\n    const commandPatterns = [\r\n      /;|\\||&&|\\|\\|/g,\r\n      /[`$]/g\r\n    ]\r\n    \r\n    // Check patterns\r\n    const allPatterns = [...sqlPatterns, ...xssPatterns, ...pathPatterns, ...commandPatterns]\r\n    allPatterns.forEach((pattern, index) => {\r\n      if (pattern.test(input)) {\r\n        const patternType = index < sqlPatterns.length ? 'SQL injection' :\r\n                          index < sqlPatterns.length + xssPatterns.length ? 'XSS' :\r\n                          index < sqlPatterns.length + xssPatterns.length + pathPatterns.length ? 'Path traversal' : 'Command injection'\r\n        patterns.push(patternType)\r\n      }\r\n    })\r\n    \r\n    return {\r\n      suspicious: patterns.length > 0,\r\n      patterns\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log security events\r\n   */\r\n  static logSecurityEvent(\r\n    event: string,\r\n    details: Record<string, any> = {},\r\n    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' = 'MEDIUM'\r\n  ): void {\r\n    const logEntry = {\r\n      timestamp: new Date().toISOString(),\r\n      event,\r\n      severity,\r\n      details\r\n    }\r\n    \r\n    console.log('SECURITY:', logEntry)\r\n    \r\n    // In production, you would send this to a logging service\r\n    // or store it in a security events table\r\n  }\r\n\r\n  /**\r\n   * Clean up expired rate limit entries\r\n   */\r\n  static cleanupRateLimitStore(): void {\r\n    const now = Date.now()\r\n    for (const [key, value] of this.rateLimitStore.entries()) {\r\n      if (now > value.resetTime) {\r\n        this.rateLimitStore.delete(key)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// RateLimitConfig is already exported above"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 989, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\"\r\nimport Google from \"next-auth/providers/google\"\r\nimport Credentials from \"next-auth/providers/credentials\"\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport bcrypt from \"bcryptjs\"\r\nimport { SimpleAccountLockoutService } from \"@/lib/security/simpleAccountLockout\"\r\nimport { SimpleAuditLogger } from \"@/lib/security/simpleAuditLogger\"\r\nimport { SessionManager } from \"@/lib/security/sessionManager\"\r\nimport { SecurityMiddleware } from \"@/lib/security/securityMiddleware\"\r\n\r\nexport const { handlers, auth, signIn, signOut } = NextAuth({\r\n  providers: [\r\n    Google({\r\n      clientId: process.env.GOOGLE_CLIENT_ID!,\r\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\r\n    }),\r\n    Credentials({\r\n      name: \"credentials\",\r\n      credentials: {\r\n        email: { label: \"Email\", type: \"email\" },\r\n        password: { label: \"Password\", type: \"password\" }\r\n      },\r\n      async authorize(credentials, req) {\r\n        const ipAddress = req?.headers?.get('x-forwarded-for') ||\r\n                         req?.headers?.get('x-real-ip') ||\r\n                         'unknown'\r\n        const userAgent = req?.headers?.get('user-agent') || 'unknown'\r\n        \r\n        console.log(' Enhanced authentication attempt:', {\r\n          hasEmail: !!credentials?.email,\r\n          hasPassword: !!credentials?.password,\r\n          email: credentials?.email,\r\n          ipAddress,\r\n          userAgent\r\n        })\r\n        \r\n        if (!credentials || typeof credentials.email !== 'string' || typeof credentials.password !== 'string') {\r\n          console.log(' Invalid credentials format')\r\n          return null\r\n        }\r\n\r\n        // Find user by email (case insensitive)\r\n        const user = await prisma.user.findUnique({\r\n          where: { email: credentials.email.toLowerCase() }\r\n        })\r\n\r\n        if (!user) {\r\n          console.log(' User not found')\r\n          // Log failed login attempt for non-existent user\r\n          await SimpleAuditLogger.logLoginAttempt(\r\n            undefined,\r\n            credentials.email.toLowerCase(),\r\n            false,\r\n            ipAddress,\r\n            userAgent,\r\n            'User not found'\r\n          )\r\n          return null\r\n        }\r\n\r\n        if (!user.password) {\r\n          console.log(' User has no password set')\r\n          await SimpleAuditLogger.logLoginAttempt(\r\n            user.id,\r\n            user.email,\r\n            false,\r\n            ipAddress,\r\n            userAgent,\r\n            'No password set'\r\n          )\r\n          return null\r\n        }\r\n\r\n        // Check account lockout status\r\n        const lockoutStatus = await SimpleAccountLockoutService.isAccountLocked(user.id)\r\n        if (lockoutStatus.locked) {\r\n          console.log(' Account is locked')\r\n          await SimpleAuditLogger.logLoginAttempt(\r\n            user.id,\r\n            user.email,\r\n            false,\r\n            ipAddress,\r\n            userAgent,\r\n            'Account locked'\r\n          )\r\n          return null\r\n        }\r\n\r\n        // Verify password\r\n        const isPasswordValid = await bcrypt.compare(credentials.password, user.password)\r\n        console.log(' Password validation:', { valid: isPasswordValid })\r\n        \r\n        if (!isPasswordValid) {\r\n          console.log(' Invalid password')\r\n          // Record failed login attempt\r\n          await SimpleAccountLockoutService.recordLoginAttempt(\r\n            user.id,\r\n            user.email,\r\n            false,\r\n            ipAddress,\r\n            userAgent,\r\n            'Invalid password'\r\n          )\r\n          return null\r\n        }\r\n\r\n        // Check for suspicious activity\r\n        const suspiciousActivity = await SessionManager.checkSuspiciousActivity(\r\n          user.id,\r\n          ipAddress,\r\n          userAgent\r\n        )\r\n        \r\n        if (suspiciousActivity.suspicious) {\r\n          console.log(' Suspicious activity detected:', suspiciousActivity.reasons)\r\n          await SimpleAuditLogger.logSecurityEvent(\r\n            'UNAUTHORIZED_ACCESS',\r\n            user.id,\r\n            {\r\n              reasons: suspiciousActivity.reasons,\r\n              ipAddress,\r\n              userAgent,\r\n              eventType: 'SUSPICIOUS_LOGIN'\r\n            },\r\n            ipAddress,\r\n            userAgent\r\n          )\r\n        }\r\n\r\n        // Create enhanced session\r\n        const sessionToken = SecurityMiddleware.generateSecureRandomString(32)\r\n        const refreshToken = SecurityMiddleware.generateSecureRandomString(32)\r\n        \r\n        await SessionManager.createSession(\r\n          user.id,\r\n          sessionToken,\r\n          refreshToken,\r\n          `Browser: ${userAgent.substring(0, 50)}`,\r\n          ipAddress,\r\n          userAgent\r\n        )\r\n\r\n        // Log successful login attempt - THIS WAS MISSING!\r\n        await SimpleAuditLogger.logLoginAttempt(\r\n          user.id,\r\n          user.email,\r\n          true,\r\n          ipAddress,\r\n          userAgent,\r\n          'Successful login'\r\n        )\r\n\r\n        const userData = {\r\n          id: user.id,\r\n          email: user.email,\r\n          name: user.name,\r\n          role: user.role,\r\n          siteIds: user.siteIds,\r\n          sessionToken,\r\n          refreshToken,\r\n        }\r\n        \r\n        console.log(' Enhanced authentication successful for user:', user.email)\r\n        return userData\r\n      }\r\n    })\r\n  ],\r\n  callbacks: {\r\n    async session({ session, token }) {\r\n      if (session.user && token) {\r\n        session.user.id = token.sub as string\r\n        session.user.role = (token.role as \"SUPER_ADMIN\" | \"ADMIN\" | \"SITE_MANAGER\") || \"SITE_MANAGER\"\r\n        session.user.siteIds = token.siteIds ? JSON.parse(token.siteIds as string) : []\r\n      }\r\n      return session\r\n    },\r\n    async jwt({ token, user }) {\r\n      if (user) {\r\n        token.id = user.id as string\r\n        token.role = user.role as \"SUPER_ADMIN\" | \"ADMIN\" | \"SITE_MANAGER\"\r\n        token.siteIds = user.siteIds as string\r\n      }\r\n      return token\r\n    },\r\n  },\r\n  pages: {\r\n    signIn: '/login',\r\n  },\r\n  session: {\r\n    strategy: \"jwt\",\r\n  },\r\n})\r\n\r\n// Custom signOut function with logout logging\r\nexport async function customSignOut(options: { callbackUrl?: string; redirect?: boolean } = {}) {\r\n  try {\r\n    // Get current session for logging\r\n    const session = await auth()\r\n    if (session?.user?.id) {\r\n      const ipAddress = 'unknown' // Would need to get from request context\r\n      const userAgent = 'unknown'\r\n      \r\n      // Log logout event\r\n      await SimpleAuditLogger.logLogout(\r\n        session.user.id,\r\n        ipAddress,\r\n        userAgent\r\n      )\r\n      \r\n      // Session cleanup would happen here when the method is implemented\r\n    }\r\n  } catch (error) {\r\n    console.error('Error during logout:', error)\r\n  }\r\n  \r\n  // Call original signOut\r\n  return signOut(options)\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1166, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/DashboardLayout.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/DashboardLayout.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/DashboardLayout.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAA2R,GACxT,yDACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1180, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/DashboardLayout.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/DashboardLayout.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/DashboardLayout.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAuQ,GACpS,qCACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1194, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1202, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/app/sites/EnhancedSitesClient.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/sites/EnhancedSitesClient.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/sites/EnhancedSitesClient.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAyS,GACtU,uEACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1216, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/app/sites/EnhancedSitesClient.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/sites/EnhancedSitesClient.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/sites/EnhancedSitesClient.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAqR,GAClT,mDACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1230, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1238, "column": 0}, "map": {"version":3,"sources":["file:///C:/Dev/asset_management/src/app/sites/page.tsx"],"sourcesContent":["import { auth } from \"@/auth\"\r\nimport { redirect } from \"next/navigation\"\r\nimport DashboardLayout from \"@/DashboardLayout\"\r\nimport EnhancedSitesClient from \"./EnhancedSitesClient\"\r\nimport { prisma } from \"@/lib/prisma\"\r\n\r\nexport default async function SitesPage() {\r\n  const session = await auth()\r\n\r\n  if (!session) {\r\n    redirect('/login')\r\n  }\r\n\r\n  // Check if user has admin privileges\r\n  if (session.user?.role !== 'SUPER_ADMIN' && session.user?.role !== 'ADMIN') {\r\n    redirect('/dashboard')\r\n  }\r\n\r\n  // Get all sites with counts, rooms, and assigned users\r\n  const sites = await prisma.site.findMany({\r\n    include: {\r\n      _count: {\r\n        select: { rooms: true, assets: true }\r\n      },\r\n      rooms: {\r\n        select: {\r\n          id: true,\r\n          name: true,\r\n          status: true\r\n        },\r\n        orderBy: { name: 'asc' }\r\n      }\r\n    },\r\n    orderBy: { name: 'asc' }\r\n  })\r\n\r\n  // Get user assignments for each site\r\n  const sitesWithUsers = await Promise.all(\r\n    sites.map(async (site) => {\r\n      const assignedUsers = await prisma.user.findMany({\r\n        where: {\r\n          siteIds: {\r\n            contains: site.id\r\n          }\r\n        },\r\n        select: {\r\n          id: true,\r\n          name: true,\r\n          email: true,\r\n          role: true\r\n        }\r\n      })\r\n      return {\r\n        ...site,\r\n        createdAt: site.createdAt.toISOString(),\r\n        updatedAt: site.updatedAt.toISOString(),\r\n        status: 'ACTIVE', // Default status since Prisma schema doesn't include status field\r\n        assignedUsers\r\n      }\r\n    })\r\n  )\r\n\r\n  return (\r\n    <DashboardLayout>\r\n      <div className=\"p-6\">\r\n        <div className=\"mb-6\">\r\n          <div className=\"flex justify-between items-center\">\r\n            <h1 className=\"text-3xl font-bold text-gray-900\">Sites Management</h1>\r\n            <a\r\n              href=\"/sites/new\"\r\n              className=\"inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500\"\r\n            >\r\n              Add New Site\r\n            </a>\r\n          </div>\r\n          <p className=\"mt-1 text-sm text-gray-600\">\r\n            Manage locations, assign users, and control site status.\r\n          </p>\r\n        </div>\r\n\r\n        <EnhancedSitesClient initialSites={sitesWithUsers} />\r\n      </div>\r\n    </DashboardLayout>\r\n  )\r\n}"],"names":[],"mappings":";;;;;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;AAEe,eAAe;IAC5B,MAAM,UAAU,MAAM,IAAA,mHAAI;IAE1B,IAAI,CAAC,SAAS;QACZ,IAAA,iMAAQ,EAAC;IACX;IAEA,qCAAqC;IACrC,IAAI,QAAQ,IAAI,EAAE,SAAS,iBAAiB,QAAQ,IAAI,EAAE,SAAS,SAAS;QAC1E,IAAA,iMAAQ,EAAC;IACX;IAEA,uDAAuD;IACvD,MAAM,QAAQ,MAAM,8HAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;QACvC,SAAS;YACP,QAAQ;gBACN,QAAQ;oBAAE,OAAO;oBAAM,QAAQ;gBAAK;YACtC;YACA,OAAO;gBACL,QAAQ;oBACN,IAAI;oBACJ,MAAM;oBACN,QAAQ;gBACV;gBACA,SAAS;oBAAE,MAAM;gBAAM;YACzB;QACF;QACA,SAAS;YAAE,MAAM;QAAM;IACzB;IAEA,qCAAqC;IACrC,MAAM,iBAAiB,MAAM,QAAQ,GAAG,CACtC,MAAM,GAAG,CAAC,OAAO;QACf,MAAM,gBAAgB,MAAM,8HAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;YAC/C,OAAO;gBACL,SAAS;oBACP,UAAU,KAAK,EAAE;gBACnB;YACF;YACA,QAAQ;gBACN,IAAI;gBACJ,MAAM;gBACN,OAAO;gBACP,MAAM;YACR;QACF;QACA,OAAO;YACL,GAAG,IAAI;YACP,WAAW,KAAK,SAAS,CAAC,WAAW;YACrC,WAAW,KAAK,SAAS,CAAC,WAAW;YACrC,QAAQ;YACR;QACF;IACF;IAGF,qBACE,8OAAC,kIAAe;kBACd,cAAA,8OAAC;YAAI,WAAU;;8BACb,8OAAC;oBAAI,WAAU;;sCACb,8OAAC;4BAAI,WAAU;;8CACb,8OAAC;oCAAG,WAAU;8CAAmC;;;;;;8CACjD,8OAAC;oCACC,MAAK;oCACL,WAAU;8CACX;;;;;;;;;;;;sCAIH,8OAAC;4BAAE,WAAU;sCAA6B;;;;;;;;;;;;8BAK5C,8OAAC,sJAAmB;oBAAC,cAAc;;;;;;;;;;;;;;;;;AAI3C","debugId":null}}]
}